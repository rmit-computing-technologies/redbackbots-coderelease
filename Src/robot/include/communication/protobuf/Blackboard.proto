// It is not recommended to use required.  Use optional to make recordings future-proof.

// The data type of each field can be checked in Blackboard.hpp, composite data type can be found in types/*.hpp

// enum values in c++ and enum values here should match, changing this may
// corrupt old recordings, so choose your values to be as futureproof as possible
// uint8_t values in c++ should be int32 values here
// uint16_t values in c++ should be int32 values here
// int values in c++ should be int32 if they are normally positive
// int values in c++ should be sint32 if they are equally likely to be positive vs negative
// repeated primitive fields need the size to be known!  https://groups.google.com/forum/#!topic/protobuf/p8FACMi1KMA

// to add a field, just add it with a unique number
// to remove a field:
//   add a comment in the .proto // removed
//   if you remove it from Blackboard.hpp, just remove the serialisation and deserialisation in serialise.cpp
// to rename a field, just rename it.  don't change the number
// to change a field type, make a new field with a new number

syntax = "proto2";

package offnao;

///////////////////////////////
// Data Structures

// Protobuf can't represent 'repeated repeated' structures
// This allows for vector<vector<int> >
//                 vector<Eigen<int,r,c> >
message RepeatedInt {
  repeated int32 values = 1;
}

// Same for floats
message RepeatedFloat {
  repeated float values = 1;
}

// Shorthand for Eigen Unsigned Int matrix
message UIntMatrix {
  optional uint32 size1 = 1;
  optional uint32 size2 = 2;
  repeated int32 data = 3;
}

// Shorthand for Eigen Float matrix
message FloatMatrix {
  optional uint32 size1 = 1;
  optional uint32 size2 = 2;
  repeated float data = 3;
}

// Int Pair (std::pair)
message PairIntInt {
  optional sint32 first = 1;
  optional sint32 second = 2;
}

///////////////////////////////
// Common shared types

message AbsCoord {
  repeated float vec = 1;
  optional FloatMatrix var = 2;
  optional float weight = 3;
}

message BBox {
  optional Point a = 1;
  optional Point b = 2;
}

// This is here for the Offnao -> Nao type
message CameraSettings {
  repeated int32 settings = 1;

  optional uint32 hflip = 2;
  optional uint32 vflip = 3;
}

message Point {
  optional sint32 x = 1;
  optional sint32 y = 2;
}

message PointF {
  optional float x = 1;
  optional float y = 2;
}

message RRCoord {
  repeated float vec = 1;
  optional FloatMatrix var = 2;
}

message XYZ_Coord {
  optional float x = 1;
  optional float y = 2;
  optional float z = 3;
}

message Rangei {
  optional int32 min = 1;
  optional int32 max = 2;
}

message Boundaryi {
  optional Rangei x = 1;
  optional Rangei y = 2;
}

///////////////////////////////
// Blackboard components

enum ActionType {
   NONE = 0;
   STAND = 1;
   WALK = 2;
   TURN_DRIBBLE = 3;
   GETUP_FRONT = 4;
   GETUP_BACK = 5;
   TIP_OVER = 6;
   KICK = 7;
   INITIAL = 8;
   DEAD = 9;
   REF_PICKUP = 10;
   GOALIE_SIT = 11;
   GOALIE_DIVE_RIGHT = 12;
   GOALIE_DIVE_LEFT = 13;
   GOALIE_CENTRE = 14;
   GOALIE_UNCENTRE = 15;
   GOALIE_INITIAL = 16;
   GOALIE_AFTERSIT_INITIAL = 17;
   DEFENDER_CENTRE = 18;
   GOALIE_FAST_SIT = 19;
   MOTION_CALIBRATE = 20;
   STAND_STRAIGHT = 21;
   LINE_UP = 22;
   TEST_ARMS = 23;
   UKEMI_FRONT = 24;
   UKEMI_BACK = 25;
   GOALIE_STAND = 26;
   KICK_IN_BLUE = 27;
   KICK_IN_RED = 28;
   GOAL_KICK_BLUE = 29;
   GOAL_KICK_RED = 30;
   CORNER_KICK_BLUE = 31;
   CORNER_KICK_RED = 32;
   GOAL_BLUE = 33;
   GOAL_RED = 34;
   PUSHING_FREE_BLUE = 35;
   PUSHING_FREE_RED = 36;
   FULLTIME = 37;
   SIT = 38;
   SIT_UNSTIFF = 39;
   NUM_ACTION_TYPES = 40;
}

message ActionCommandAll {
  message Head {
    optional float yaw = 1;
    optional float pitch = 2;
    optional bool isRelative = 3;
    optional float yawSpeed = 4;
    optional float pitchSpeed = 5;
  }

  message Body {
    optional ActionType actionType = 1 [default = NONE];
    optional sint32 forward = 2;
    optional sint32 left = 3;
    optional float turn = 4;
    optional float power = 5;
    optional float bend = 6;
    optional float speed = 7;
    optional float kickDirection = 8;
    enum Foot {
      LEFT = 0;
      RIGHT = 1;
    }

    optional Foot foot = 9;
    optional bool isFast = 10;
    optional bool misalignedKick = 11;
    optional bool useShuffle = 12;
    optional bool leftArmBehind = 13;
    optional bool rightArmBehind = 14;
    optional bool blocking = 15;
  }

  message LED {
    message rgb {
      optional bool red = 1;
      optional bool green = 2;
      optional bool blue = 3;
    }

    message rgbSegments {
      repeated rgb segments = 1;
    }

    optional uint32 leftEar = 1;
    optional uint32 rightEar = 2;
    optional rgbSegments leftEye = 3;
    optional rgbSegments rightEye = 4;
    optional rgb chestButton = 5;
    optional rgb leftFoot = 6;
    optional rgb rightFoot = 7;
  }

  optional Head head = 1;
  optional Body body = 2;
  optional LED leds = 3;
  // optional float sonar = 4;
  enum Stiffen {
    NONE = 0;
    STIFFEN = 1;
  }

  optional Stiffen stiffen = 5;
}

message GameController {
  optional bool team_red = 1; // removed
  optional int32 player_number = 2;
}

message JointValues {
  repeated float angles = 1;
  repeated float stiffnesses = 2;
  repeated float temperatures = 3;
  repeated float currents = 4;
}

enum RobotVisionInfoType {
  rUnknown = 0;
  rOwnTeam = 1;
  rEnemyTeam = 2;
}

message SensorValues {
  optional JointValues joints = 1;
  repeated float sensors = 2;
  // repeated float sonar = 3;
}

message SharedStateEstimationBundle {
  optional AbsCoord robotPos = 1;
  optional AbsCoord ballPosRRC = 2;
  optional AbsCoord ballVelRRC = 3;
  optional bool haveBallUpdate = 4;
  optional bool haveTeamBallUpdate = 5;
}

message Motion {
  message Pose {
    optional FloatMatrix topCameraToWorldTransform = 1;
    optional FloatMatrix botCameraToWorldTransform = 2;
    optional FloatMatrix origin = 3;
    optional FloatMatrix zunit = 4;
    optional FloatMatrix topCOrigin = 5;
    optional FloatMatrix botCOrigin = 6;
    optional PairIntInt horizon = 7;
    repeated sint32 topExclusionArray = 8;
    repeated sint32 botExclusionArray = 9;
    optional FloatMatrix neckToWorldTransform = 10;
  }

  message Odometry {
    optional float forward = 1;
    optional float left = 2;
    optional float turn = 3;
  }

  message MotionDebugInfo {
    optional FeetPosition feetPosition = 1;
  }

  message FeetPosition {
    optional FootPosition left = 1;
    optional FootPosition right = 2;
  }

  message FootPosition {
    optional float x = 1;
    optional float y = 2;
    optional float theta = 3;
  }

  optional SensorValues sensors = 1;
  optional Pose pose = 2;
  optional XYZ_Coord com = 3;
  optional Odometry odometry = 4;
  optional ActionCommandAll active = 5;
  optional JointValues jointRequest = 6;
  optional MotionDebugInfo motionDebugInfo = 7;
}

message Perception {
  optional uint32 behaviour = 1;
  optional uint32 kinematics = 2;
  optional uint32 stateEstimation = 3;
  optional uint32 total = 4;
  optional uint32 vision = 5;
}

message Kinematics {
  message FloatParameters {
    optional float cameraPitchTop = 1;
    optional float cameraYawTop = 2;
    optional float cameraRollTop = 3;
    optional float cameraYawBottom = 4;
    optional float cameraPitchBottom = 5;
    optional float cameraRollBottom = 6;
    optional float bodyPitch = 7;
  }

  // repeated RepeatedInt sonarFiltered = 1;
  optional FloatParameters parameters = 2;
  // optional SensorValues sensorsLagged = 3;
}

// looks like a composite type
message Behaviour {
  message BehaviourRequest {
    // optional WhichCamera whichCamera = 1;
    optional ActionCommandAll actions = 2;
    // optional bool goalieAttacking = 3;
    // optional bool goalieDiving = 4;
    // optional int32 secondsSinceLastKick = 5;
    // optional bool doingBallLineUp = 6;
    // optional bool isInReadyMode = 7;
    // optional float timeToReachBall = 8;
    // optional float timeToReachDefender = 9;
    // optional float timeToReachMidfielder = 10;
    // optional float timeToReachUpfielder = 11;
    // optional int32 kickoffSide = 12;
    // optional bool wantCrazyBall = 13;
    // optional string behaviourHierarchy = 14;
    // optional int32 currentRole = 15;
    // optional int32 role = 16;
    // optional bool playingBall = 17;
    // optional bool needAssistance = 18;
    // optional bool isAssisting = 19;
    // optional bool isKickedOff = 20;
    // optional bool isFollowing = 21;
    // optional int32 ballLostFrames = 22;
    // optional sint32 readyPositionAllocation0 = 23;
    // optional sint32 readyPositionAllocation1 = 24;
    // optional sint32 readyPositionAllocation2 = 25;
    // optional sint32 readyPositionAllocation3 = 26;
    // optional sint32 readyPositionAllocation4 = 27;
    optional BehaviourDebugInfo behaviourDebugInfo = 28;
    optional BehaviourSharedData behaviourSharedData = 29;
  }

  repeated BehaviourRequest request = 1;
}

message BehaviourSharedData {
  // optional bool goalieAttacking = 1;
  // optional bool goalieDiving = 2;
  // optional float timeToReachBall = 3;
  // optional float timeToReachUpfielder = 4;
  // optional float timeToReachMidfielder = 5;
  // optional float timeToReachDefender = 6;
  // optional int32 currentRole = 7;
  optional int32 role = 8;
  optional bool playingBall = 9;
  optional bool needAssistance = 10;
  optional bool isAssisting = 11;
  optional int32 secondsSinceLastKick = 12;
  // optional bool isFollowing = 13;
  optional bool isKickedOff = 14;
  // optional bool doingBallLineUp = 15;
  // optional bool isInReadyMode = 16;
  // optional ReadySkillPositionAllocation readyPositionAllocation = 17;
  // optional int32 ballLostFrames = 18;
  optional float walkingToX = 19;
  optional float walkingToY = 20;
  optional float walkingToH = 21;
  optional float playingBallScore = 22;
}

message Vision {

  enum BallStatus {
    notSeen = 0;
    seen = 1;
    guessed = 2;
  }

  message BallInfo {
    optional BallStatus status = 1;
    optional RRCoord rr = 2; 
    optional int32 radius = 3;
    optional Point imageCoords = 4;
    optional bool topCamera = 5;
  }

  enum PostInfoType {
    pNone = 0;
    pLeft = 1;
    pRight = 2;
    pHome = 4;
    pAway = 8;

    pHomeLeft = 5;
    pHomeRight = 6;
    pAwayLeft = 9;
    pAwayRight = 10;
  }

  enum PostInfoDirection {
    pToLeftOf = 0;
    pToRightOf = 1;
    pUnknown = 2;
  }

  message PostInfo {
    optional RRCoord rr = 1;
    optional PostInfoType type = 2;
    optional BBox imageCoords = 3;
    optional float wDistance = 4;
    optional float kDistance = 5;
    optional bool trustDistance = 6;
    optional PostInfoDirection dir = 7;
  }

  enum Cameras {
    TOP_CAMERA = 0;
    BOT_CAMERA = 1;
    BOTH_CAMERAS = 2;
    OLD_DETECTION = 3;
  }

  message RobotVisionInfo {
    optional RRCoord rr = 1;
    optional RobotVisionInfoType type = 2 [default = rUnknown];
    optional Cameras cameras = 3 [default = BOTH_CAMERAS];
    optional BBox imageCoords = 4;
    optional BBox topImageCoords = 5;
    optional BBox botImageCoords = 6;
  }

  message FieldBoundary {
    repeated RepeatedFloat boundaryOnField = 1;
    repeated RepeatedInt boundaryInImage = 2;
    optional bool isValid = 3;
    optional bool extrapolated = 4;
    optional bool odd = 5;
    repeated RepeatedInt boundaryInImageLowerBound = 6;
    repeated RepeatedInt boundaryInImageUpperBound = 7;
  }

  enum FieldFeatureInfoType {
    fNone = 0;
    fLine = 1;
    fCorner = 2;
    fTJunction = 3;
    fPenaltySpot = 4;
    fCentreCircle = 5;
    fFieldLinePoint = 6;
    fXJunction = 7;
    fParallelLines = 8;
    fGoalBoxCorner = 9;
  }

  message FieldFeatureInfo {
    message FieldLinePointInfo {
      optional Point p = 1;
      optional Point rrp = 2;
    }

    message LineInfo {
      optional Point p1 = 1;
      optional Point p2 = 2;
      optional sint32 t1 = 3;
      optional sint32 t2 = 4;
      optional sint32 t3 = 5;
      optional RRCoord rr = 6;
    }

    message CornerInfo {
      optional Point p = 1;
      optional Point e1 = 2;
      optional Point e2 = 3;
    }

    message TJunctionInfo {
      optional Point p = 1;
    }

    message GoalBoxCornerInfo {
      optional Point p = 1;
      optional bool left_corner = 2;
    }

    message PenaltySpotInfo {
      optional Point p = 1;
      optional sint32 w = 2;
      optional sint32 h = 3;
    }

    message XJunctionInfo {
      optional Point p = 1;
    }

    message CentreCircleInfo {
    }

    message ParallelLinesInfo {
      optional LineInfo l1 = 1;
      optional LineInfo l2 = 2;
    }

    optional RRCoord rr = 1;
    optional FieldFeatureInfoType type = 2;
    optional Point p1 = 3;
    optional Point p2 = 4;
    optional PointF field1 = 5;
    optional PointF field2 = 6;
    optional bool topCamera = 7;
  }

  message RefereeGesture {
    enum Gesture {
      none = 0;
      kickInBlue = 1;
      kickInRed = 2;
      goalKickBlue = 3;
      goalKickRed = 4;
      cornerKickBlue = 5;
      cornerKickRed = 6;
      goalBlue = 7;
      goalRed = 8;
      pushingFreeKickBlue = 9;
      pushingFreeKickRed = 10;
      fullTime = 11;
      substitution = 12;
      standbyToReady = 13;
      count = 14;
    }

    optional Gesture gesture = 1;
  }

  message RegionI {
    optional bool is_top_camera_ = 1;
    optional BBox bounding_box_rel_ = 2;
    optional BBox bounding_box_fovea_ = 3;
    optional BBox bounding_box_raw_ = 4;
    optional int32 n_raw_cols_in_region_ = 5;
    optional int32 n_raw_rows_in_region_ = 6;
    optional int32 density_to_raw_ = 7;
    optional int32 y_offset_raw_ = 8;
    optional int32 x_offset_raw_ = 9;
    optional int32 raw_total_width_ = 10;
    optional int32 raw_to_fovea_density_ = 11;
    optional int32 fovea_width_ = 12;
  }

  enum CameraResolution {
      defaultRes = 0;
      w320h240   = 1;
      w640h480   = 2;
      w1280h960  = 3;
      noRequest  = 4;
  }

  message CameraImage {
    optional uint32 height = 1;
    optional uint32 width  = 2;

    optional bytes data  = 3;
  }

  enum Colour {
    cGREEN = 0;
    cWHITE = 1;
    cBLACK = 2;
    cBACKGROUND = 3;
    cBODY_PART = 4;
    cNUM_COLOURS = 5;
  }

  // TODO (TW): Renumber after vision implementation finished
  optional int64 timestamp = 1;
  repeated FieldBoundary fieldBoundary = 2;
  repeated BallInfo balls = 3;
  repeated FieldFeatureInfo fieldFeatures = 4;
  optional RefereeGesture refereeGesture = 5;

  // OLD VISION ELEMENTS
  repeated RobotVisionInfo robots = 103;
  repeated RegionI regions = 106;
  
  optional CameraResolution topResolution = 10;
  optional CameraResolution botResolution = 11;
  optional CameraSettings topCameraSettings = 12;
  optional CameraSettings botCameraSettings = 13;
  optional UIntMatrix topAutoExposureWeightTable = 14;
  optional UIntMatrix botAutoExposureWeightTable = 15;

  optional CameraImage topImage = 20;
  optional CameraImage botImage = 21;

  optional bytes topFrameJPEG = 22;
  optional bytes botFrameJPEG = 23;
}

message Receiver {
  message SPLStandardMessage {
    optional string header = 1;
    optional uint32 version = 2;
    optional uint32 playerNum = 3;
    optional uint32 teamNum = 4;
    optional uint32 fallen = 5;
    repeated float pose = 6;
    optional float ballAge = 7;
    repeated float ball = 8;
    optional uint32 numOfDataBytes = 9;
    optional bytes data = 10;
  }

  message BroadcastData {
    optional int32 playerNum = 1;
    repeated float robotPos = 2;
    optional AbsCoord ballPosAbs = 3;
    optional RRCoord ballPosRR = 4;
    optional SharedStateEstimationBundle sharedStateEstimationBundle = 5;
    optional BehaviourSharedData behaviourSharedData = 6;
    optional ActionType acB = 7;
    optional float uptime = 8;
    optional uint32 gameState = 9;
  }

  repeated SPLStandardMessage message = 1;
  repeated BroadcastData data = 2;
  repeated int32 lastReceived = 3;
  // TODO: add the sizes to the message
  repeated bool incapacitated = 4;
}

message StateEstimation {
  message RobotObstacle {
    optional RRCoord rr = 1;
    optional RobotVisionInfoType type = 2;
    optional AbsCoord rrc = 3;
    optional AbsCoord pos = 4;
    optional double tangentHeadingLeft = 5;
    optional double tangentHeadingRight = 6;
    optional RRCoord evadeVectorLeft = 7;
    optional RRCoord evadeVectorRight = 8;
  }

  repeated RobotObstacle robotObstacles = 1;
  optional AbsCoord robotPos = 2;
  repeated AbsCoord allRobotPos = 3;
  optional RRCoord ballPosRR = 4;
  optional AbsCoord ballPosRRC = 5;
  optional AbsCoord ballVelRRC = 6;
  optional AbsCoord ballVel = 7;
  optional AbsCoord ballPos = 8;
  optional AbsCoord teamBallPos = 9;
  optional AbsCoord teamBallVel = 10;
  optional SharedStateEstimationBundle sharedStateEstimationBundle = 11;
  optional bool havePendingOutgoingSharedBundle = 12;
  // TODO: add the sizes to the message
  repeated bool havePendingIncomingSharedBundle = 13;
  optional AbsCoord walkToPoint = 14;
}

message BehaviourDebugInfo {
  optional string bodyBehaviourHierarchy = 1;
  optional string headBehaviourHierarchy = 2;
  optional bool haveBallManoeuvreTarget = 3;
  optional float ballManoeuvreTargetX = 4;
  optional float ballManoeuvreTargetY = 5;
  optional float ballManoeuvreHeadingError = 6;
  optional string ballManoeuvreType = 7;
  optional bool ballManoeuvreHard = 8;
  optional bool anticipating = 9;
  optional float anticipateX = 10;
  optional float anticipateY = 11;
  optional float anticipateH = 12;
}

// Debugger Information
// TODO: Move all "DebugInfo" into here eventually
message Debugger {

  // Vision debug information
  message VisionDebugger {
    
    // Data structures for vision debugging
    message ScanGrid {
      message ScanGridLine {
        optional int32 x = 1;
        optional int32 yMin = 2;
        optional int32 yMax = 3;
        optional uint32 lowResYMaxIndex = 4;
        optional uint32 yMaxIndex = 5;
      }

      message ScanGridHorizontalLine {
        optional int32 y = 1;
        optional int32 left = 2;
        optional int32 right = 3;
      }
      
      repeated int32 fullResY = 1;
      repeated ScanGridHorizontalLine lowResHorizontalLines = 2;
      repeated ScanGridLine verticalLines = 3;
      optional int32 fieldLimit = 4;
      optional uint32 lowResStart = 5;
      optional uint32 lowResStep = 6;
    }

    message ScanLineRange {
      optional uint32 fromSl = 1;
      optional uint32 toSl = 2;
      optional uint32 upperSl = 3;
      optional uint32 lowerSl = 4;
      optional uint32 leftSl = 5;
      optional uint32 rightSl = 6;
    }

    message ScanLineRegion {
      enum ScanLineColor {
        unset = 0;
        black = 1;
        white = 2;
        field = 3;
        none = 4;
      }

      optional ScanLineRange range = 1;
      optional ScanLineColor color = 2;
    }

    message ColorScanLineRegionsHorizontal {
      message HorizontalScanLine {
        optional uint32 y = 1;
        repeated ScanLineRegion regions = 2;
      }

      repeated HorizontalScanLine scanLines = 1;
    }

    message ColorScanLineRegionsVertical {
      message VerticalScanLine {
        optional uint32 x = 1;
        repeated ScanLineRegion regions = 2;
      }

      repeated VerticalScanLine scanLines = 1;
      optional uint32 lowResStart = 2;
      optional uint32 lowResStep = 3;
    }

    message PenaltyMarkRegions {
      repeated Boundaryi regions = 1;
    }

    message BallSpots {
      repeated RepeatedInt ballSpots = 1;
      optional bool firstSpotIsPredicted = 2;
    }

    message IntersectionCandidates {
      repeated IntersectionCandidate intersections = 1;
    }

    message IntersectionCandidate {
      // optional Vector2f pos = 1;
      optional Point img = 1;
      // optional Vector2f dir1 = 3;
      // optional Vector2f dir2 = 4;
    }

    message Spot {
      optional float imageX = 1;
      optional float imageY = 2;
      optional float fieldX = 3;
      optional float fieldY = 4;
      optional uint32 candidate = 5;
    }

    message Candidate {
      optional float n0X = 1;
      optional float n0Y = 2;
      optional float d = 3;
      repeated Spot spots = 4;
    }

    message Candidates {
      repeated Candidate horizontalCandidates = 1;
      repeated Candidate verticalCandidates = 2;
    }

    message Vector2f {
      optional float x = 1;
      optional float y = 2;
    }

    message CircleCandidate {
      optional float centerX = 1;
      optional float centerY = 2;
      optional float radius = 3;
      repeated Vector2f fieldSpots = 4;
      repeated Vector2f imageSpots = 5;
    }

    message CircleCandidates {
      repeated CircleCandidate candidates = 1;
    }

    message Line {
      message Vector2i {
        optional int32 x = 1;
        optional int32 y = 2;
      }

      message GeometryLine {
        optional Vector2f base = 1;
        optional Vector2f direction = 2;
      }

      optional GeometryLine line = 1;  // The fitted line in field coordinates
      repeated Vector2f spotsInField = 2;  // Spots on this line (relative field coordinates, NOT FITTED TO LINE)
      repeated Vector2i spotsInImg = 3;  // Spots on this line (image coordinates, NOT FITTED TO LINE)
      optional Vector2i firstImg = 4;  // First spot of the line in image coordinates, NOT FITTED TO LINE
      optional Vector2i lastImg = 5;  // Last spot of the line in image coordinates, NOT FITTED TO LINE
      optional Vector2f firstField = 6;  // Start of the fitted line in field coordinates
      optional Vector2f lastField = 7;  // End of the fitted line in field coordinates
      optional bool belongsToCircle = 8;
      optional float length = 9;
    }

    message LineSpots {
      repeated Line lines = 1;
    }

    message CentreCircle {
      optional Point image = 1;
      optional bool wasSeen = 2;
    }

    message PlaneSpots {
      repeated Spot spots = 1;
    }

    message Comparison {
      optional Spot pointInImage = 1;
      optional Spot referencePoint = 2;
      optional int32 type = 3; 
    }

    message IsWhiteSpots {
      repeated Comparison comparisons = 1;
    }

    message ObstacleImage {
      optional int32 top = 1;
      optional int32 bottom = 2;
      optional int32 left = 3;
      optional int32 right = 4;
      optional bool bottomFound = 5;
      optional bool fallen = 6;
      optional float confidence = 7;
      optional float distance = 8;
    }

    message RobotObstaclesImage {
      repeated ObstacleImage obstacles = 1;
    }

    message RefereeKeypoint {
      optional Vector2f position = 1;
      optional bool valid = 2;
    }

    message RefereeKeypoints {
      enum Keypoint {
        nose = 0;
        leftEye = 1;
        rightEye = 2;
        leftEar = 3;
        rightEar = 4;
        leftShoulder = 5;
        rightShoulder = 6;
        leftElbow = 7;
        rightElbow = 8;
        leftWrist = 9;
        rightWrist = 10;
        leftHip = 11;
        rightHip = 12;
        leftKnee = 13;
        rightKnee = 14;
        leftAnkle = 15;
        rightAnkle = 16;
        count = 17;
      }

      repeated RefereeKeypoint points = 1;
    }

    // Vision debug messages
    repeated ScanGrid scanGrid = 1;
    repeated BallSpots ballSpots = 2;
    repeated ColorScanLineRegionsHorizontal colorScanLineRegionsHorizontal = 3;
    repeated ColorScanLineRegionsVertical colorScanLineRegionsVertical = 4;
    repeated PenaltyMarkRegions penaltyMarkRegions = 5;
    repeated Candidates candidates = 6;
    repeated Candidates candidatesBefore = 7;
    repeated Candidates candidatesAfter = 8;
    repeated LineSpots lineSpots = 9;
    repeated CentreCircle centreCircle = 10;
    repeated CircleCandidates circleCandidates = 11;
    repeated IntersectionCandidates intersectionCandidates = 12;
    repeated PlaneSpots planeSpots = 13;
    repeated IsWhiteSpots isWhiteSpots = 14;
    repeated RobotObstaclesImage robotsImage = 15;
    optional RefereeKeypoints refereeKeypoints = 16;
  }

  // Messages
  optional VisionDebugger vision = 1;
}

// The top-level blackboard
message Blackboard {
  optional uint64 mask = 1;
  optional GameController gameController = 2;
  optional Motion motion = 3;
  optional Behaviour behaviour = 4;
  optional Perception perception = 5;
  optional Kinematics kinematics = 6;
  optional Vision vision = 7;
  optional Receiver receiver = 8;
  optional StateEstimation stateEstimation = 9;
  optional Debugger debugger = 10;
}

///////////////////////////////
// Message Types for transmitting from Offnao to Nao
message UpdateCameraSettings {
  optional int64 whichCamera = 1;
  optional CameraSettings settings = 2;
}